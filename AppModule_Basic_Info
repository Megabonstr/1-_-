
Процедура МодульПриложения()
	
	// Это модуль приложения (управляемого)
	// Здесь описываются переменные, процедуры и функции, 
	// выполняемые как правило при запуске и/или завершении работы системы
	
	// Модуль это программа на встроенном языке системы 1с
	// используется для описания алгоритмов выполнения программного кода
	// и может вызываться для разных объектов (сущностей) конфигурации
	
	// Структура Модулей в 1с 
	// Любой модуль условно делится на три части и код выполняется сверху вниз
	// 1. Объявляются глобальные переменные
	// 2. Объявляются и описываются процедуры и функции
	// 3. Значения присваиваются в переменные, вызываются процедуры и функции
	// Нарушение данного порядка приведет к ошибке при компиляции кода
	
КонецПроцедуры

Процедура ПолезныеГорячиеКлавиши() 
	
	// Комментарии:
	// Установить курсор в нужной строке, нажать "Ctrl + /" (в цифровом блоке клавиатуры где NumLock) - закомментировать 
	// Установить курсор в нужной строке, нажать "Shift + Ctrl + /" (в цифровом блоке клавиатуры где NumLock) - раскомментировать 
	
	// Справка:
	// Нажать F1 - основная справка программы
	// Нажать "Ctrl + Shift + F1" - Синтакс Помошник
	// Установить курсор на нужном слове, нажать "Ctrl + F1" - поиск выделенного слова в Синтакс Помшнике 
	
	// Автоформатирование под стандарт
	// Выделить нужный блок кода и нажать "Alt + Shift + F" - будут проставлены или убраны лишние отступы
	
	// Проверка на ошибки синтаксиса - Нажать "CTRL + F7" 
	
	// Сохранить текущую конфигурацию "F7"
	
	// Запустить отладу - "F5"
	// Завершить отладу - "Shift + F5"
	
	// При отладке перейти к значению эелемента
	// Установить курсор на нужном слове, нажать "Shift + F9" 
	
КонецПроцедуры

Процедура ПеременныеИПримитивныеТипыДанных()
	
	// Переменные в 1С должны именоваться согласно стандарту PascalCase
	// т.е. все Слова с БольшойБуквы, так же в имени не допускаются пробелы и любые спецсимволы 
	// кроме символа нижнее подчеркивание "_", цифры можно использовать, но нельзя начинать с них название;
	
	// Язык именования выбирается исходя из основного языка описываемой конфигурации
	// если пишем на русском для пользователей РФ, то именование переменных например StringX недопустимо
	// и наоборот - если пишем конфигурации для англоязычных пользователей - недопустимо использование русского языка
	
	// Примитивные типы - к ним относятся простые типы данных, имеющих однозначное значение и тип данных
	// К ним относятся - строка, число, дата, Неопределено, NULL, булево и Тип
	
	// Строка
	ЭтоСтрока = "Текст или цифры 123456 или дата 2023-01-25 но все равно это строка текста";
	ЭтоМногоСтрочнаяСтрока = "Строка1
	|Строка2"; 
	ЭтоТожеМногострочнаяСтрока = "Строка1" "Строка2";
	
	Сообщить(ЭтоСтрока);
	Сообщить(ЭтоМногоСтрочнаяСтрока);
	Сообщить(ЭтоТожеМногострочнаяСтрока);
	
	//!! Все законченые строки кода называются Операторами и закрываются точкой с запятой ";"
	// Кроме объявления процедур и функций, они не являются операторами, а просто изолируют (выделяют) кусок кода
	
	// Число
	ЭтоЧисло = 999; // Присваиваем число переменной ЭтоЧисло. Число указывается цифрами и не заключается в кавычки;
	
	//!! При объявлении переменной например Перем ЭтоЧисло; 
	//!! При выполнении программы в оперативной памяти будет выделено(зарезервированно) место под эту переменную;
	//!! У переменной появится уникальный адрес и возможность ссылаться на неё, а так же значение = Неопределено;
	//!! Если переменная объявляется с оператором присваивания "=", то значением в памяти будет присвоенное значение;
	
	// Операции с числами
	// Встроенный язык системы позволяет использовать все современные методы математических вычеслений
	СуммаЧисел 			= 15 + 45; // 60
	ПроизведениеЧисел 	= 2 * 2; // 4
	СложныеВычисления 	= (15 + 45 / 2 * 2) * 3 + (138 / 15) * 10; // 272 
	
	//!! Система позволяет преобразовывать типы например при конкатенации строк (значений)
	ПреобразованиеКЧислу 	= 15 + "9";  // 9 будет преобразованов к числу и будет произведена операция сложения
	ПреобразованиеКСтроке 	= "15" + 9;  // 9 будет преобразовано в строку и результат будет "159"
	ПреобразованиеКДате 	= '2023 01 25' + "20230103"; // 16.09.2023 3:28:23
	// "20230103" будет преобразованов число и к дате прибавлено кол-во секунд    
	
	//!! Важно помнить - нельзя преобразовать к числу например строку "ф2ал34" - будет ошибка
	//!! К строке можно преобразовть любой тип данных поэтому для сообщений которые начинаются не со строки
	//!! Можно использовать "" пустую строку в начале сообщения, тогда все последующие значения будут преобразованы к строке
	
	// Дата
	ЭтоДата1 = '20230125';	// 25.01.2023 0:00:00 - обычное написание даты в 1С - формат ГГГГММДД
	ЭтоДата2 = '2023 01 25';// 25.01.2023 0:00:00 - Допустимое написание через пробел, для большей читабельности
	ЭтоДата3 = '2023-01-25';// 25.01.2023 0:00:00 - Вывод быдет таким же как и для примеров выше
	
	// Дата всегда выводится со временем, для изменения формата используется специальные методы 
	ЭтоДата1 = Формат('20230125', "ДЛФ=DD"); // 25 января 2023 года без времени  
	ЭтоДень = День(ТекущаяДата()); // 25 - выведет текущий день в виде числа месяца 
	ЭтоМесяц = Месяц(ТекущаяДата()); // 1 - выведет текущий месяц в виде числа месяца 
	ЭтоГод = Год(ТекущаяДата()); // 2 023 - выведет текущий год в виде числа месяца
	
	// Булево
	// Значение логического типа Истина/Ложь (1 или 0)  
	ЭтоИстина = Истина;
	ЭтоЛожь = Ложь;
	
	// Тип
	// Значения данного типа позволяют определчть и сравнивать типы значения 
	ЭтоЧисло = 123;
	ТипЧисло = Тип("Число");
	
	Если ТипЗнч(ЭтоЧисло) = ТипЧисло Тогда
		Сообщить(ТипЧисло); // Число
	КонецЕсли;
	
	Сообщить(ТипЗнч(ЭтоЧисло)); // Число
	
	// Неопределено 
	// Данное значение используется в качестве ПУСТОГО значения при работе с объектами конфигурации
	ПустаяПеременная = Неопределено; // Можно создать переменную с таким типом для дальнейшей обработки 
	
	// Так же значения данного типа возвращаются их некоторых функций как правило поиска в коллекциях
	// Это позволяет делать проверки результатов и не получать ошибки отсутвия значения
	
	// NULL  
	// Такое значение может быть получено при работе с базой данных, при определении отсутвующего значения
	// Т.е. элемент например Строка есть, мы можем к ней обратиться, но значение в строке отсутствует 
	
КонецПроцедуры

Процедура УсловныеОператоры()
	
	// Условные операторы используются для сравнения значений и ветвления исполняемого кода
	// Если / ИначеЕсли / Иначе / КонецЕсли
	
	Число1 = 100;
	Число2 = 200;
	
	// Если задает начало проверки, затем указывается выражения для сравнения
	// после задания условий обязательно используется ключевое слово Тогда
	Если Число1 > Число2 И (Число2 > 0 ИЛИ Число1 <> 0) Тогда
		Сообщить("Число1 больше чем Число2");
		// ИначеЕсли Тогда позволяет задать множественную проверку условий
		// проверка будет завершена когда хотя бы одно из условий ИначеЕсли вернет Истина
	ИначеЕсли Число1 < Число2 И (Число2 > 0 ИЛИ Число1 <> 0) Тогда
		Сообщить("Число2 больше чем Число1");
		// В отличие от ИначеЕсли, Иначе не позволяет задать разных условий
		// Срабатывает только в случае если проверки выше вернули Ложь, и не требует дополнительных проверок
	Иначе
		Сообщить("Числа не соответсвуют условиям для сравнения!");
		// Обязательное ключевое слово для завершения сравнения
	КонецЕсли;
	
	// Операторы сравнения для использования в связке с условными операторами
	// В порядке приоритета от приоритетного к менее приоритетному
	
	// () - круглые скобки, задают максимальный приоритет в сравнении
	// Математичеческие операторы выполняются по классическим правилам:
		// +А -Б Унарные плюс и минус, меняющие значение числа на отрицательное
		// * и / Умножение и деление
		// + и - Сложение и вычитание
		// < = > <> - 
	// НЕ - логическое отрицание меняет значение Истина/Ложь на противоположное
	// И - оператор выполняется после проверки условий в круглых скобках и выполнения математических операций
	// ИЛИ - последния операратор который сравнивает резултат нескольких сравнений
	
	Если (Число1 + Число2) <> (НЕ (Число2 - Число1)) ИЛИ (Число1 > 0 И Число2 > 0)Тогда
		Сообщить("Вот такая вот хитрая проверка");
	КонецЕсли; 
	
	//!! Для большей читабельности кода следует мат. выражения и сложные операции сравнения
	//!! заключать в круглые скобки, так будет легче и однозначней понять что происходит
	
	Условие1 = Истина;
	Условие2 = Ложь;
	Условие3 = Истина;
	Условие4 = Ложь;
	Условие5 = Ложь;
	Условие6 = Истина;
	
	СложноеУсловие = Условие1 И (Условие2 ИЛИ Условие3) ИЛИ Условие4 И Условие5 И НЕ Условие6;
	Сообщить(СложноеУсловие);
	
	
КонецПроцедуры

Процедура Циклы()
	
	// В 1с существует три вида циклов
	// По значению  - Цикл Для (FOR)
	// По условию   - Цикл Пока (WHILE)
	// По коллекции - Цикл для каждого (FOR i IN ...)
	
	// Все циклы работают по одному принципу
	// Объявляется сам цикл по ключевому слову - Для, Пока или Для Каждого
	// Указывается диапазон значений для итераций цикла - Для Шаг = 1 по 10 // Для Каждого Эл Из МассивСтрок
	// Затем обязательно указывается ключевое слово Цикл и КонецЦикла
	// В теле цикла описываются алгоритмы которые требуется выполнить на каждой итерации
	
	// Цикл по значению
	// Для использования данного цикла используется условный счетчик
	// который можно (и нужно) задать сразу в цикле 
	
	ГраницаДиапазона = 10;
	// В данном цикле переменная Шаг является автоматическим счетчиком итераций
	// в которой мы можем задать только начальное значение в виде положительного или отрицательного числа
	
	Для Шаг = 1 По ГраницаДиапазона Цикл
		// На каждой итерации цикла Счетчик Шаг будет прибавлять 1 (еденицу) пока не станет <= ГраницаДиапазона
		Сообщить(Шаг); // 1,2,3,4,5,6,7,8,9,10 - когда счетчик достигнет 10 проверка условий вернет Ложь и цикл завершится
	КонецЦикла;
	// Обязательное ключевое слово КонецЦикла, так же закрывает Оператор после чего обязательно ставится ";"
	
	//!! При использовании цикла по счетчику для обхода массива по индексам 
	//!! стоит учитывать что индексы начинаются с 0, так же
	//!! если в качестве границы диапазона использовать метод Количество()
	//!! стоит помнить что Количество элементов массива нужно уменьшить на 1: Количество() - 1
	//!! а лучше использовать метод ВГраница() который возвращает максимальный индекс в Массиве
	
	// Циклы могут быть вложены друг в друга что позволяет делать вычисления или обработку данных
	// разной сложности, например простую таблицу умножения можно записать так:
	
	// Таблица умножения циклом по счетчику 
	
	// На первой итерации для Числа1 запускается вложенный цикл
	// который Умножает Число1 на Число2 которое увеличивается на 1 на каждой итерации
	// когда вложенный цикл становится равен установленной границе диапазона
	// запускается вторая итерация первого цикла в которой Число1 увеличивается на 1
	// и снова запускается установленное количество итераций вложенного цикла
	// таким образом получается таблица умножения Числа1 от 1 до 10 на Число2 от 1 до 10
	
	Для Число1 = 1 По 10 Цикл	
		Для Число2 = 1 По 10 Цикл
			Сообщить("" + Число1 + " * " + Число2 + " = " + Число1 * Число2);
		КонецЦикла;
	КонецЦикла;
	
	// Второй вид Цикла - По Условию (Пока)
	
	Число1 = 10;
	
	// В данном цикле итерации будут выполняться Пока заданное условие не вернет Ложь
	Пока Число1 > 0 Цикл
		Сообщить(Число1);
		//!! В цикле по условию очень легко получить бесконечный цикл из-за чего программа "зависнет"
		//!! поэтому обязтельно нужно прописывать условие завершения цикла, в данном случае изменяя значения числа 
		Число1 = Число1 - 1;	
	КонецЦикла; 
	
	// Таблица умножения циклом по условию 
	Число1 = 1;
	
	// В данном примере стоит учитывать несколько моментов
	// 1. Прописать условия завершения для каждого из циклов
	// 2. Число2 необходимо переопределять на каждой итерации основного цикла
	Пока Число1 <= 10 Цикл
		Число2 = 1; // На каждой итерации сбрасываем значение переменной для вложенного цикла до 1 
		
		Пока Число2 <= 10 Цикл
			Сообщить("" + Число1 + " * " + Число2 + " = " + Число1 * Число2);
			Число2 = Число2 + 1; // На каждой итерации изменяем числоя для корректного завершения вложенного цикла
		КонецЦикла;
		
		Число1 = Число1 + 1; // На каждой итерации изменяем числоя для корректного завершения основного цикла
	КонецЦикла;
	
	// Цикл По коллекции, третий и последний, но не по значению
	// Как следует из названия используется для обхода коллекций
	// таких как - Массив, Структура, Соответсвие, СписокЗначений, ТЗ и ДЗ
	
	// Создаем Новый пустой массив (список значений с уникальными индексами)
	МассивЧисел = Новый Массив;
	
	// Заполняем Массив цифрами от 1 до 10 с помощью цикла по счетчику
	Для Шаг = 1 По 10 Цикл
		МассивЧисел.Добавить(Шаг); 
	КонецЦикла;
	
	// Теперь выведем все значения из массива циклом по коллекции
	Для каждого Элемент Из МассивЧисел Цикл
		// Для наглядного отображения содержимого Массива выведем все данные: Индекс и Значение
		Сообщить("Индекс массива: " + МассивЧисел.Найти(Элемент) + " - " + "Значение: " + Элемент);
	КонецЦикла; 
	
	//!! Внутри циклов помимо вложенных циклов можно использовать условные операторы 
	//!! и другие инструменты обработки данных
	
	// Для более гибкого управления поведением итераций циклов 
	// существует еще два Оператора
	// 1. Продолжить
	// 2. Прервать
	
	// Оператор Продолжить завершает текущую итерацию цикла и возвращает в начало цикла
	// Оператор Прервать завершает текущий цикл
	
	Для Шаг = 1 По 10 Цикл
		Если Шаг < 5 Тогда
			Сообщить("Текущая итерация = " + Шаг + ", Запускаем Цикл сначала!");
			Продолжить;
		Иначе
			Сообщить("Текущая итерация = " + Шаг + ", Условия выполнены - Завершаем Цикл!");
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ФункцияИПроцедура()

	

КонецПроцедуры

Процедура ВстроенныеФункцииЧисло()

	

КонецПроцедуры

Процедура ВстроенныеФункцииСтрока()

	

КонецПроцедуры

Процедура ВстроенныеФункцииДата()

	

КонецПроцедуры

Процедура ПростыеЗадачиСоСтрокамиЧисламиДатами()

	

КонецПроцедуры















